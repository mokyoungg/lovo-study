# ch6. 기본적인 리팩터링

## 6-1. 함수 추출하기

```
function printOwing(invoice){
  printBanner();
  let outstanding = calculateOutstanding();
  //세부사항 출력
  console.log(`고객명: ${invoice.customer}`)
  console.log(`채무액: ${outstanding}`)
}

function printOwing(invoice){
  printBanner();
  ley outstanding = calculateOutstanding();
  printDetail(outstanding)

  function prtinDetail(outstanding){
    console.log(`고객명: ${invoice.customer}`)
    console.log(`채무액: ${outstanding}`)
  }
}
```

### 배경

- 코드 조각을 찾아 무슨 일을 하는지 파안한 다음, 독립된 함수로 추출하고 목적에 맞는 이름을 붙인다.
- 코드를 독립된 함수로 묶는 경우, '목적과 구현을 분리'하는 방식이 가장 합리적이다.
- 코드를 보고 무슨 일을 하는지 파악하는데 한참이 걸린다면 그 부분을 함수로 추출한 뒤 '무슨 일'에 걸맞는 이름을 짓는다.
- 함수가 짧으면 캐싱하기가 더 쉽기 때문에 컴파일러가 최적화하는 데 더 유리할 때가 많다.

### 절차

- 함수를 새로 만들고 목적을 잘 드러내는 이름을 붙인다.('어떻게'가 아닌 '무엇'을 하는지가 드러나야 한다.)
- 추출한 코드를 원본 함수에서 복사하여 새 함수에 붙여넣는다.
- 추출한 코드 중 원본 함수의 지역 변수를 참조하거나 추출한 함수의 유효범위를 벗어나는 변수는 없는지 검사한다. 있다면 매개변수로 전달한다.
- 변수를 다 처리했다면 컴파일한다.
- 원본 함수에서 추출한 코드 부분을 새로 만든 함수를 호출하는 문장으로 바꾼다.
- 테스트한다.
- 다른 코드에 방금 추출한 것과 똑같거나 비슷한 코드가 없는지 살핀다. 있다면 방금 추출한 새 함수를 호출하도록 바꿀지 검토한다.

## 6-2. 함수 인라인하기

```
function getRating(driver){
  return moreThanFiveLateDeliveries(driver) ? 2: 1;
}

function moreThanFiveLateDeliveries(driver){
  return driver.numberOfLateDeliveries > 5;
}

function getRating(driver){
  return (driver.numberOfLasteDeliveries >5) ? 2:1;
}
```

### 배경

- 때로는 함수 본문이 이름만큼 명확한 경우도 있다.
- 또는 함수 본문 코드를 이름만큼 깔끔하게 리팩터링할 때도 있다.
- 이럴 때는 함수를 제거한다, 간접 호출은 유용하지만 쓸데없는 간접 호출은 거슬릴 뿐이다.
- 다른 함수로 단순히 위임하기만 하는 함수들이 너무 많아서 위임 관계가 복잡하게 얽혀있으면 인라인해버린다.

### 절차

- 다형 메서드인지 확인하다.
- 인라인할 함수를 호출할 곳을 모두 찾는다.
- 각 호출문을 함수 본문으로 교체한다.
- 하나씩 교체할 때마다 테스트한다.
- 함수 정의(원래 함수)를 삭제한다.

## 6-3. 변수 추출하기

```
return order.quanity*order.itemPrice -
  Math.max(0, order.quantity - 500) * order.itemPrice * 0.05 +
  Math.min(order.quantity * order.itemPrice * 0.1, 100);


const basePrice = order.quantiy * order.itemPrice;
const quantityDiscount = Math.max(0, order.quantity -500) * order.itemPrice * 0.05;
const shipping = Math.min(basePrice * 0.1, 100);
return basePrice - quantityDiscount + shipping;

```

### 배경

- 표현식이 너무 복잡해서 이해하기 어려울 때가 있다.
- 지역변수를 활요하면 표현식을 쪼개 관리하기 더 쉽게 만들 수 있다.
- 복잡한 로직을 구성하는 단계마다 이름을 붙일 수 있어서 코드의 목적을 훨씬 명확하게 드러낼 수 있다.
- 추가한 변수는 디버깅에도 도움이 된다.
- 이름을 붙이기로 했다면 그 이름이 들어갈 문맥도 살펴야한다.
- 현재 함수 안에서만 의미가 있다면 변수로 추출하는 것이 좋다.
- 함수를 벗어난 넓은 문맥에서까지 의미가 된다면 그 넓은 범위에서 통용되는 이름을 생갹해야한다.(변수가 아닌 (주로) 함수로 추출해야한다.)

### 절차

- 추철하려는 표현식에 부작용은 없는지 확인한다.
- 불변 변수를 하나 선언하고 이름을 붙일 표현식의 복제본을 대입힌다.
- 원본 표현식을 새로 만든 변수로 교체한다.
- 테스트한다.
- 표현식을 여러 곳에서 사용한다면 각각을 새로 만든 변수로 교체한다.(교체마다 테스트)

## 6-4. 변수 인라인하기

```
let basePrice = anOrder.basePrice;
return (basePrice > 1000);

return anOrder.basePrice > 1000;
```

### 배경

- 변수의 이름이 원래 표현식과 다를 바 없을 때도 있다.
- 변수가 주변 코드를 리팩터링하는데 방해가 되기도 한다.

### 절차

- 대입문의 우변ㅇ에서 부작용이 생기지는 않는지 확인한다.
- 변수가 불변으로 선언되지 않았다면 불변으로 만든 후 테스트한다.
- 이 변수를 가장 처음 사용하는 코드를 찾아서 대입문 우변의 코드로 바꾼다.
- 테스트한다.
- 변수를 사용하는 부분을 모두 교체할 때까지 이 과정을 반복한다.
- 변수 선언문과 대입문을 지운다.
- 테스트한다.

## 6-5. 함수 선언 바꾸기

```
function circum(radius) {...}

function circumference(radius){...}
```

### 배경

- 함수는 프로그램을 작은 부분으로 나누는 주된 수단이다.
- 함수 선언은 각 부분이 서로 맞물리는 방식을 표현하며, 실질적으로 소프트웨어 시스템의 구성 요소를 조립하는 연결부 역할을 한다.
- 연결부에서 가장 중요한 요소는 함수의 이름이다.
- 이름이 좋으면 함수의 구현 코드를 살펴볼 필요없이 호출문만 보고도 무슨 일을 하는지 파악할 수 있다.
- 함수의 매개변수는 함수가 외부 세계와 어우러지는 방식을 정의한다.
- 매개변수는 함수를 사용하는 문맥을 설정한다.

### 절차

- 매개변수를 제거하려거든 먼저 함수 본문에서 제거 대상 매개변수를 참조하는 곳은 없는지 확인한다.
- 메서드 선언을 원하는 형태로 바꾼다.
- 기존 메서드 선언을 참조하는 부분을 모두 찾아서 바뀐 형태로 수정한다.
- 테스트한다.

## 6-6. 변수 캡슐화하기

```
let defaultOwner = {firstName: '마틴', lastName: '파울리'}

let defaultOwnerData = {firstName: '마틴', lastName:'파울리'}
export function defaultOwner {return defaultOwnerData}
export function setDefaultOwner(arg){defaultOwnerData = arg}
```

### 배경

- 데이터는 함수보다 다루기가 까다롭다.
- 유효범위가 넓어질수록 다루기가 어려워진다.
- 접근할 수 있는 범위가 넓은 데이터를 옮길 때는 먼저 그 데이터로의 접근을 독점하는 함수를 만드는 식으로 캡슐화하는 것이 가장 좋은 방법이다.
- 데이터 재구성이라는 어려운 작업을 함수 재구성이라는 더 단순한 작업으로 변환하는 것이다.
- 데이터 캡슐화는, 데이터를 변경하고 사용하는 코드를 감시할 수 있는 확실한 통로가 되어주기 때문에 데이터 변경 전 검증이나 변경 후 추가 로직을 쉽게 끼워넣을 수 있다.

### 절차

- 변수로의 접근과 갱신을 전담하는 캡슐화 함수들을 만든다.
- 정적 검사를 수행한다.
- 변수를 직접 참조하던 부분을 모두 적절한 캡슐화 함수 호출로 바꾼다. 하나씩 바꿀 때마다 테스트한다.
- 변수의 접근 범위를 제한한다.
- 테스트한다.
- 변수 값이 레코드라면 레코드 캡슐화하기를 적용할지 고려해본다.

## 6-7. 변수 이름 바꾸기

```
let a = height * width;
let area = height * width;
```

### 배경

- 명확한 프로그래밍의 핵심을 이름짓기이다.
- 변수는 프로그래머가 하려는 일에 관해 많은 것을 설명해준다.

### 절차

- 폭넓게 쓰이는 변수라면 변수 캡슐화하기를 고려한다.
- 이름을 바꿀 변수를 참조하는 곳을 모두 찾아서, 하나씩 변경한다.
- 테스트한다.

## 6-8. 매개변수 객체 만들기

```
function amountInvoice(startDate, endDate){...}
function amountReceived(startDate, endDate){...}
function amountOverdue(startDate, endDate){...}

function amountInvoice(aDateRange){...}
function amountReceived(aDateRange){...}
function amountOverdue(aDateRange){...}
```

### 배경

- 데이터 항목 여러 개가 이 함수에서 저 함수로 함께 몰려다니는 경우를 자주 본다.
- 데이터 무리를 발견하면 데이터 구조 하나로 모아준다.
- 데이터 뭉치를 데이터 구조로 묶으면 데이터 사이의 관계가 명확해진다는 이점을 얻는다.
- 코드를 더 근본적으로 바꿔준다.
- 데이터 구조에 담길 데이터에 공통으로 적용되는 동작을 추출해서 함수로 만든다.

### 절차

- 적당한 데이터 구조가 아직 마련되어 있지 않다면 새로 만든다.
- 테스트한다.
- 함수 선언 바꾸기로 새 데이터 구조를 매개변수로 추가한다.
- 테스트한다.
- 함수 호출 시 새로운 데이터 구조 인스턴스를 넘기도록 수정한다. 하나씩 수정할때마다 테스트한다.
- 기존 매개변수를 사용하면 코드를 새 데이터 구조의 원소를 사용하도록 바꾼다.
- 다 바꿨다면 기존 매개변수를 제거하고 테스트한다.

## 6-9. 여러 함수를 클래스로 묶기

```
function base(aReading){...}
function tableCharge(aReading){...}
function calculateBaseCharge(aReading){...}

class Reading {
  base(){...}
  tableChange(){...}
  calculateBaseCharge(){...}
}
```

### 배경

- 클래스는 대다수의 최신 프로그래밍 언어가 제공하는 기본적인 빌딩 블록이다.
- 클래스는 데이터와 함수를 하나의 공유 환경으로 묶은 후, 다른 프로그램 요소와 어우러질 수 있도록 그중 일부를 외부에 제공한다.

### 절차

- 함수들이 공유하는 공통 데이터 레코드를 캡슐화 한다.
- 공통 레코드를 사용하는 함수 각각을 새 클래스로 옮긴다
- 데이터를 조작하는 로직들은 함수로 추출해서 새 클래스로 옮긴다.

## 6-10. 여러 함수를 변환 함수로 묶기

```
function base(aReading){...}
function taxableCharge(aReading){...}

function enrichReading(argReading){
  const aReading = _.cloneDeep(argReading);
  aReading.baseCharge = base(aReading);
  aReading.taxableCharge = taxableCharge(aReading);
  return aReading
}
```

### 배경

- 소프트웨어는 데이터를 입력받아 여러가지 정보를 도출하곤한다.
- 도출된 정보는 여러 곳에서 사용될 수 있는데, 그러다 보면 이 정보가 사용되는 곳마다 같은 도출 로직이 반복되기도 한다.
- 이런 도출 작업들을 한데로 모아두면 좋다.
- 이렇게 하기 위한 방법으로 변환 함수를 사용할 수 있다.
- 변환 함수는 원본 데이터를 입력받아서 필요한 정보를 모두 도출한 뒤, 각각을 출력 데이터의 필드에 넣어 반환한다.
- 원본 데이터가 코드 안에서 갱신될 때는 클래스로 묶는 편이 훨씬 낫다.
- 여러 함수를 한데 묶는 이유 하나는 도출 로직이 중복되는 것을 피하기 위해서이다.

### 절차

- 변환할 레코드를 입력받아서 값을 그대로 반환하는 반환 함수를 만든다.
- 묶을 함수 중 함수 하나를 골라서 본문 코드를 반환 함수로 옮기고, 처리 결과를 레코드에 새 필드로 기록한다. 그런 다음 클라이언트 코드가 이 필드를 사용하도록 수정한다.
- 테스트한다.
- 나머지 관련 함수도 위 과정에 따라 처리한다.

## 6-11. 단계 쪼개기

```
const orderData = drderString.split(/\s+/);
const productPrice = priceList[orderData[0].split('-')[1]];
const orderPrice = parseInt(orderData[1]) * productPrice;

const orderRecord = parseOrder(order);
const orderPrice = price(orderRecord, priceList);

function parseOrder(aString){
  const values = aString.split(/\s+/);
  return ({
    productID: values[0].split['-'][1],
    quantity: parseInt(value[1])
  })
}
function price(order, priceList) {
  return order.quantity * priceList[order.productID]
}

```

### 배경

- 서로 다른 두 대상을 한꺼번에 다루는 코드를 발견하면 각각을 별개 모듈로 나누는 방법을 모색한다.
- 두 대상을 동시에 생각할 필요 없이 하나에만 집중하기 위해서다.
- 분리하는 가장 간편한 방법은, 동작을 연이은 두 단계로 쪼개는 것이다.
- 각 단계는 서로 확연히 다른 일을 수행해야 한다.

### 절차

- 두 번째 단계에 해당하는 코드를 독립 함수로 추출한다.
- 테스트한다.
- 중간 데이터 구조를 만들어서 앞에서 추출한 함수의 인수로 추가한다.
- 테스트한다.
- 추출한 두 번째 단계 함수의 매개변수를 하나씩 검토한다. 그중 첫번쨰 단계에서 사용되는 것은 중간 데이터 구조로 옮긴다. 하나씩 옮길 때마다 테스트한다.
- 첫 번째 단계 코드를 함수로 추출하면서 중간 데이터 구조를 반환하도록 한다.

---

## 인상적인 부분

#### 함수 추출하기

> 코드를 독립된 함수로 묶는 경우, '목적과 구현을 분리'하는 방식이 가장 합리적이다.

#### 변수 추출하기

> 지역변수를 활용하면 표현식을 쪼개 관리하기 더 쉽게 만들 수 있다.
> 복잡한 로직을 구성하는 단계마다 이름을 붙일 수 있어서 코드의 목적을 훨씬 명확하게 드러낼 수 있다.

#### 함수 선언 바꾸기

> 함수는 프로그램을 작은 부분으로 나누는 주된 수단이다.
> 함수 선언은 각 부분이 서로 맞물리는 방식을 표현하며, 실질적으로 소프트웨어 시스템의 구성 요소를 조립하는 연결부 역할을 한다.
> 연결부에서 가장 중요한 요소는 함수의 이름이다.
> 이름이 좋으면 함수의 구현 코드를 살펴볼 필요없이 호출문만 보고도 무슨 일을 하는지 파악할 수 있다.
> 함수의 매개변수는 함수가 외부 세계와 어우러지는 방식을 정의한다.
> 매개변수는 함수를 사용하는 문맥을 설정한다.

### 변수 캡슐화하기

> 데이터는 함수보다 다루기가 까다롭다.
> 유효범위가 넓어질수록 다루기가 어려워진다.
> 접근할 수 있는 범위가 넓은 데이터를 옮길 때는 먼저 그 데이터로의 접근을 독점하는 함수를 만드는 식으로 캡슐화하는 것이 가장 좋은 방법이다.

#### 매개 변수 객체만들기

> 데이터 항목 여러 개가 이 함수에서 저 함수로 함께 몰려다니는 경우를 자주 본다.
> 데이터 무리를 발견하면 데이터 구조 하나로 모아준다.

#### 단계 쪼개기

> 서로 다른 두 대상을 한꺼번에 다루는 코드를 발견하면 각각을 별개 모듈로 나누는 방법을 모색한다.
> 각 단계는 서로 확연히 다른 일을 수행해야 한다.

## 배운점 / 느낀점

ch6에서 나온 기본적인 리팩터링의 방법들은 다양하지만,
이 방법들이 공유하는 주제(컨셉)는 '코드를 쪼개거나 묶고 해당 결과에 명확한 이름을 지어주다.' 인 것 같다.

이는 ch2에서 리팩터링을 하는 이유와 밀접한 관계를 가지고 있다.
리팩터링은 (코드의 유지 보수, 앞으로의 성능 개선 등을 위해) 명확하게 코드를 작성하는 방법이다.
그리고 이를 위해 코드가 (하나의) 고유한 일(만)을 수행할 수 있도록 도와주는 방법이기도 하다.

함수/변수를 쪼개는 일은 하나의 함수가 고유한 일만을 수행할 수 있도록 도와주는 방법이다.
그리고 그러한 함수/변수에 명확한 이름을 짓는 것으로 프로젝트(외부 세계)에서 어떠한 역할을 하는지 코드를 보지 않고도 이해할 수 있게 도와준다.

쪼개는 것보다 어려운 것은 묶는 일이다.(함수/변수의 인라인)
명확한 이름으로 지어진, 고유한 일을 하는 함수가 인라인이 될 가능성은 없을 것 같다.
('무엇을' 하는지 목적이 분명한 함수/변수라면 인라인의 여지가 없다고 생각한다.)
반대로 '무엇을' 하는지 목적이 불분명한 함수/변수는 인라인의 대상이 된다.

인라인과는 또 다른 묶는 개념이라고 할 수 있는 흩어져 있는 여러 함수를 클래스나 변환함수로 묶는 방법은 아직 잘 이해가 되지 않는다.
그러나 매개변수들을 묶어 객체로 만드는 개념은 매우 신기하고 기회가 된다면 사용해보고 싶다.
