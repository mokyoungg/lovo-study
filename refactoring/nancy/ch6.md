### Ch 6. 기본적인 리팩터링

1. 함수 추출하기

- '목적과 구현을 분리'한다.
- 함수의 목적 ('무엇을 하는가') 을 잘 드러내는 이름을 붙인다.
- 시스템 시간을 알려주는 함수를 직접 호출하지 않고 (i.e., Date.now()), 시스템 시계를 감싸는 객체 (i.e., Clock.today)를 사용하는 것이 좋다.

2. 함수 인라인하기

- 간접 호출을 너무 과하게 쓰지 않는다.
- 단계를 잘게 나눠서 처리한다.

3. 변수 추출하기

- 복잡한 로직을 구성하는 단계마다 이름을 붙여 변수로 추출한다.

4. 변수 인라인하기

5. 함수 선언 바꾸기

- public API 를 리팩터링할 때는 새 함수를 추가한 다음, 예전 함수를 deprecated 대상으로 지정한다. 모든 클라이언트가 새 함수로 이전할 때까지 기다린다.
- 마이그레이션 절차 (7단계) 를 참고한다 (p.181)

6. 변수 캡슐화하기

- 접근할 수 있는 범위가 넓은 데이터를 옮길 때는 먼저 그 데이터로의 접근을 독점하는 함수로 캡슐화한다 (i.e., getter, setter functions).
- (가변) 데이터의 범위가 넓을수록 캡슐화해야 한다.
- OOP 에서 객체의 데이터는 항상 private 으로 유지한다.
- 필드값을 변경할 수 있게 하려면 데이터의 복제본을 리턴하는 방식으로 getter function 을 작성할 수 있다 (i.e., Object.assign()).
- 필드값을 아예 변경할 수 없게 만들기 위해 레코드 캡슐화하기 방식을 사용할 수 있다.

7. 변수 이름 바꾸기

8. 매개변수 객체 만들기

- 몰려다니는 매개변수를 하나의 객체로 묶는다.

9. 여러 함수를 클래스로 묶기

- 여러 함수들이 공유하는 공통 환경을 더 명확하게 표현할 수 있다.
- 각 함수에 전달되는 인수를 줄여서 객체 안에서의 함수 호출을 더 간결하게 만들 수 있다.
- 클래스 객체를 시스템의 다른 부분에 전달하기 위한 참조를 제공할 수 있다.

10. 여러 함수를 변환 함수로 묶기

- 원본 데이터를 입력 받아서 필요한 정보를 모두 도출한 뒤, 각각의 출력 데이터를 필드에 넣어 반환한다.
- 원본 데이터가 코드 안에서 갱신될 때는 데이터의 일관성을 유지하기 위해 '여러 함수를 클래스로 묶기' 방식을 채택하는 것이 낫다.

11. 단계 쪼개기

- 단계 ('phase') 를 명확히 분리한다.
